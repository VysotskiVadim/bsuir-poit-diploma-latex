\lstset{style=fsharpstyle}

\section{Используемые технологии} 
\label{sec:practice:technology_used}

Выбор технологий является важным предварительным этапом разработки сложных информационных систем.
Платформа и язык программирования, на котором будет реализована система, заслуживает большого внимания, так как исследования показали, что выбор языка программирования влияет на производительность труда программистов и качество создаваемого ими кода~\cite[c.~59]{mcconnell_2005}.

Ниже перечислены некоторые факторы, повлиявшие на выбор технологий:
\begin{itemize}
\item Разрабатываемое ПО должно работать на операционной системе Windows~7 и более новых версиях системы.
\item Среди различных платформ разработки имеющийся программист лучше всего знаком с разработкой на платформе \dotnet{}.
\item Дальнейшей поддержкой проекта, возможно, будут заниматься разработчики, не принимавшие участие в выпуске первой версии.
\item Имеющийся разработчик имеет опыт работы с объекто"=ориентированными и с функциональными языками программирования.
\end{itemize}

Основываясь на опыте работы имеющихся программистов разрабатывать ПО целесообразно на платформе \dotnet{}.
Приняв во внимание необходимость обеспечения доступности дальнейшей поддержки ПО, возможно, другой командой программистов, целесообразно не использовать малоизвестные и сложные языки программирования.
С учетом этого фактора выбор языков программирования сужается до четырех официально поддерживаемых Microsoft и имеющих изначальную поддержку в Visual Studio~2012: \cppcli{}, \csharp{}, \vbnet{} и \fsharp{}.
Необходимость использования низкоуровневых возможностей \cppcli{} в разрабатываемом ПО отсутствует, следовательно данный язык можно исключить из списка кандидатов.
\vbnet{} уступает по удобству использования двум другим кандидатам из нашего списка.
Оставшиеся два языка программирования \csharp{} и \fsharp{} являются первостепенным, элегантными, мультипарадигменными языками программирования для платформы \dotnet.
Таким образом, с учетом вышеперечисленных факторов, целесообразно остановить выбор на следующих технологиях:
\begin{itemize}
  \item операционная система Windows~7;
  \item платформа разработки \dotnet{};
  \item языки программирования \csharp{} и \fsharp{}.
\end{itemize}
Для реализации поставленной задачи нет необходимости в использовании каких"=либо прикладных библиотек для создания настольных или веб"=приложений, достаточно использовать стандартные библиотеки указанных выше языков.
Поддержка платформой \dotnet{} различных языков программирования позволяет использовать язык, который наиболее просто и <<красиво>> позволяет решить возникающую задачу.
Разрабатываемое программное обеспечение в некоторой степени использует данное преимущество платформы.
Язык \csharp{} больше подходит для создания высокоуровнего дизайна проложения (иерархия классов и интерфейсов, организация пространств имен и публичного программного интерфейса), язык \fsharp{} "--- для реализации логики приложения, функций и методов~\cite{fsdg_2010}, прототипирования различных идей.
В разрабатываемом программном продукте \csharp{} используется для предоставления удобного программного интерфейса, \fsharp{} "--- для прототипирования и реализации вычислительной логики.
Далее проводится характеристика используемых технологий и языков программирования более подробно.



\subsection{Программная платформа \dotnet}
\label{sub:practice:microsoft_net}
Программная платформа \dotnet{} является одной из реализаций стандарта ECMA-335~\cite{ecma_335} и является современным инструментом создания клиентских и серверных приложений для операционной системы Windows.
Первая общедоступная версия \netfx{} вышла в феврале 2002 года.
С тех пор платформа активно эволюционировала и на данный момент было выпущено шесть версии данного продукта.
На данный момент номер последней версии \netfx{} "--- 4.5.
Платформа \dotnet{} была призвана решить некоторые наболевшие проблемы, скопившиеся на момент её выхода, в средствах разработки приложений под Windows. 
Ниже перечислены некоторые из них~\cite[с.~\Rmnum{14}\,--\,\Rmnum{17}]{richter_2007_ru}:
\begin{itemize}
  \item сложность создания надежных приложений;
  \item сложность развертывания и управления версиями приложений и библиотек;
  \item сложность создания переносимого ПО;
  \item отсутствие единой целевой платформы для создателей компиляторов;
  \item проблемы с безопасным исполнением непроверенного кода;
  \item великое множество различных технологий и языков программирования, которые не совместимы между собой.
\end{itemize}

Многие из этих проблем были решены.
Далее более подробно рассматривается внутреннее устройство \dotnet{}.

Основными составляющими компонентами \dotnet{} являются общая языковая исполняющая среда (Common Language Runtime) и стандартная библиотека классов (Framework Class Library).
CLR представляет из себя виртуальную машину и набор сервисов обслуживающих исполнение программ написанных для \dotnet{}.
Ниже приводится перечень задач, возлагаемых на CLR~\cite{marchenko_2007}:
\begin{itemize}
  \item загрузка и исполнение управляемого кода;
  \item управление памятью при размещении объектов;
  \item изоляция памяти приложений;
  \item проверка безопасности кода;
  \item преобразование промежуточного языка в машинный код;
  \item доступ к расширенной информации от типах "--- метаданным;
  \item обработка исключений, включая межъязыковые исключения;
  \item взаимодействие между управляемым и неуправляемым кодом (в том числе и COM"=объектами);
  \item поддержка сервисов для разработки (профилирование, отладка и т.\,д.).
\end{itemize}

Программы написанные для \dotnet{} представляют из себя набор типов взаимодействующих между собой.
\dotnet{} имеет общую систему типов (Common Type System, CTS).
Данная спецификация описывает определения и поведение типов создаваемых для \dotnet{}~\cite{richter_2012_en}.
В частности в данной спецификации описаны возможные члены типов, механизмы сокрытия реализации, правила наследования, типы"=значения и ссылочные типы, особенности параметрического полиморфизма и другие возможности предоставляемые CLI.
Общая языковая спецификация (Common Language Specification, CLS) "--- подмножество общей системы типов. 
Это набор конструкций и ограничений, которые являются руководством для создателей библиотек и компиляторов в среде \netfx{}.
Библиотеки, построенные в соответствии с CLS, могут быть использованы из любого языка программирования, поддерживающего CLS. 
Языки, соответствующие CLS (к их числу относятся языки \csharp{}, \vbnet{}, \cppcli{}), могут интегрироваться друг с другом. CLS "--- это основа межъязыкового взаимодействия в рамках платформы \dotnet{}~\cite{marchenko_2007}.

Некоторые из возможностей, предоставляемых \dotnet{}: верификация кода, расширенная информация о типах во время исполнения, сборка мусора, безопасность типов, "--- невозможны без наличия подробных метаданных о типах из которых состоит исполняемая программа.
Подробные метаданные о типах генерируются компиляторами и сохраняются в результирующих сборках.
Сборка "--- это логическая группировка одного или нескольких управляемых модулей или файлов ресурсов, является минимальной единицей с точки зрения повторного использования, безопасности и управлениями версиями~\cite[с.~6]{richter_2012_en}.

Одной из особенностей \dotnet{}, обеспечивающей переносимость программ без необходимости повторной компиляции, является представление исполняемого кода приложений на общем промежуточном языке (Common Intermediate Language, CIL). 
Промежуточный язык является бестиповым, стековым, объекто"=ориентированным ассемблером~\cite[с.~16\,--\,17]{richter_2012_en}.
Данный язык очень удобен в качестве целевого языка для создателей компиляторов и средств автоматической проверки кода для платформы \dotnet{}, также язык довольно удобен для чтения людьми.
Наличие промежуточного языка и необходимость создания производительных программ подразумевают наличие преобразования промежуточного кода в машинный код во время исполнения программы.
Одним из компонентов общей языковой исполняющей среды, выполняющим данное преобразование, является компилятор времени исполнения (Just-in-time compiler) транслирующий промежуточный язык в машинные инструкции, специфические для архитектуры компьютера на котором исполняется программа.

Ручное управление памятью всегда являлось очень кропотливой и подверженной ошибкам работой.
Ошибки в управлении памятью являются одними из наиболее сложных в устранении типами программных ошибок, также эти ошибки обычно приводят к непредсказуемому поведению программы, поэтому в \dotnet{} управление памятью происходит автоматически~\cite[с.~505\,--\,506]{richter_2012_en}.
Автоматическое управление памятью является механизмом поддержания иллюзии бесконечности памяти.
Когда объект данных перестает быть нужным, занятая под него память автоматически освобождается и используется для построения новых объектов данных.
Имеются различные методы реализации такого автоматического распределения памяти~\cite[с.~489]{sicp_2006_ru}.
В~\dotnet{} для автоматического управления памятью используется механизм сборки мусора (garbage collection).
Существуют различные алгоритмы сборки мусора со своими достоинствами и недостатками. 
В \dotnet{} используется алгоритм пометок (mark and sweep) в сочетании с различными оптимизациями, такими как, например, разбиение всех объектов по поколениям и использование различных куч для больших и малых объектов.

Ниже перечислены, без приведения подробностей, некоторые важные функции исполняемые общей языковой исполняющей средой:
\begin{itemize}
  \item обеспечение многопоточного исполнения программы;
  \item поддержание модели памяти, принятой в CLR;
  \item поддержка двоичной сериализации;
  \item управление вводом и выводом;
  \item структурная обработка исключений;
  \item возможность размещения исполняющей среды внутри других процессов.
\end{itemize}

Как уже упоминалось выше, большую ценностью для \dotnet{} представляет библиотека стандартных классов "--- соответствующая CLS"=спецификации объектно"=ориентированная библиотека классов, интерфейсов и системы типов (типов"=значений), которые включаются в состав платформы \dotnet{}.
Эта библиотека обеспечивает доступ к функциональным возможностям системы и предназначена служить основой при разработке .NET"=приложений, компонент, элементов управления~\cite{marchenko_2007}.



\subsection{Язык программирования \csharp{}}
\label{sub:practice:csharp_overview}
\csharp{} "--- объектно"=ориентированный, типо"=безопасный язык программирования общего назначения.
Язык создавался с целью повысить продуктивность программистов.
Для достижения этой цели в языке гармонично сочетаются простота, выразительность и производительность промежуточного кода, получаемого после компиляции.
Главным архитектором и идеологом языка с первой версии является Андрес Хейлсберг (создатель Turbo Pascal и архитектор Delphi).
Язык \csharp{} является платформенно нейтральным, но создавался для хорошей работы с \dotnet{}~\cite{albahari_2012_en}.
Этот язык сочетает простой синтаксис, похожий на синтаксис языков \cpp{} и \java{}, и полную поддержку всех современных объектно-ориентированных концепций и подходов. В качестве ориентира при разработке языка было выбрано безопасное программирование, нацеленное на создание надежного и простого в сопровождении кода~\cite{volosevich_cs_2011}.

Язык имеет богатую поддержку парадигмы объекто"=ориентированного программирования, включающую поддержку инкапсуляции, наследования и полиморфизма.
Отличительными чертами \csharp{} с точки зрения ОО парадигмы являются:
\begin{itemize}
  \item Унифицированная система типов. 
        В \csharp{} сущность, содержащая данные и методы их обработки, называется типом.
        В \csharp{} все типы, являются ли они пользовательскими типами, или примитивами, такими как число, производны от одного базового класса.
  \item Классы и интерфейсы.
        В классической объекто"=ориентированной парадигме существуют только классы.
        В \csharp{} дополнительно существуют и другие типы, например, интерфейсы.
        Интерфейс "--- это сущность напоминающая классы, но содержащая только определения членов.
        Конкретная реализация указанных членов интерфейса происходит в типах, реализующих данный интерфейс.
        В частности интерфейсы могут быть использованы при необходимости проведения множественного наследования (в отличие от языков \cpp{} и Eiffel, \csharp{} не поддерживает множественное наследование классов).
  \item Свойства, методы и события.
        В чистой объекто"=ориентированной парадигме все функции являются методами.
        В \csharp{} методы являются лишь одной из возможных разновидностей членов типа, в \csharp{} типы также могут содержать свойства, события и другие члены.
        Свойство "--- это такая разновидность функций, которая инкапсулирует часть состояния объекта.
        Событие "--- это разновидность функций, которые реагируют на изменение состояния объекта~\cite{albahari_2012_en}.
\end{itemize}

В большинстве случаев \csharp{} обеспечивает безопасность типов в том смысле, что компилятор контролирует чтобы взаимодействие с экземпляром типа происходило согласно контракту, который он определяют.
Например, компилятор \csharp{} не скомпилирует код который обращается со строками, как если бы они были целыми числами.
Говоря более точно, \csharp{} поддерживает статическую типизацию, в том смысле что большинство ошибок типов обнаруживаются на стадии компиляции.
За соблюдение более строгих правил безопасности типов следит исполняющая среда.
Статическая типизация позволяет избавиться от широкого круга ошибок, возникающих из-за ошибок типов. 
Она делает написание и изменение программ более предсказуемыми и надежными, кроме того, статическая типизация позволяет существовать таким средствам как автоматическое дополнение кода и его предсказуемый статический анализ.
Еще одним аспектом типизации в \csharp{} является её строгость.
Строгая типизация означает, что правила типизации в языке очень <<сильные>>.
Например, язык не позволяет совершать вызов метода, принимающего целые числа, передавая в него вещественное число~\cite{albahari_2012_en}. 
Такие требования спасают от некоторых ошибок.

\csharp{} полагается на автоматическое управление памятью со стороны исполняющей среды, предоставляя совсем немного средств для управления жизненным циклом объектов.
Не смотря на это, в языке все же присутствует поддержка работы с указателями.
Данная возможность предусмотрена для случаев, когда критически важна производительность приложения или необходимо обеспечить взаимодействие с неуправляемым кодом~\cite{albahari_2012_en}. 

Как уже упоминалось \csharp{} не является платформенно зависимым языком.
Благодаря усилиям компании Xamarin возможно писать программы на языке \csharp{} не только для операционных систем Microsoft, но и ряда других ОС.
Существуют инструменты создания приложений на \csharp{} для серверных и мобильных платформ, например: iOS, Android, Linux и других.

Создатели языка \csharp{} не являются противниками привнесения в язык новых идей и возможностей, в отличии от создателей одного из конкурирующих языков.
Каждая новая версия компилятора языка привносит различные полезные возможности, которые отчаются требованиям индустрии. 
Далее приводится краткий обзор развития языка.

Первая версия \csharp{} была похожа по своим возможностям на \java{} 1.4, несколько их расширяя: так, в \csharp{} имелись свойства (выглядящие в коде как поля объекта, но на деле вызывающие при обращении к ним методы класса), индексаторы (подобные свойствам, но принимающие параметр как индекс массива), события, делегаты, циклы \lstinline!foreach!, структуры, передаваемые по значению, автоматическое преобразование встроенных типов в объекты при необходимости (boxing), атрибуты, встроенные средства взаимодействия с неуправляемым кодом (DLL, COM) и прочее~\cite{csharp_wiki_2013_ru}. 

Версия \dotnet{} 2.0 привнесла много новых возможностей в сравнении с предыдущей версией, что отразилось и на языках под эту платформу.
Проект спецификации \csharp{} 2.0 впервые был опубликован Microsoft в октябре 2003 года; в 2004 году выходили бета"=версии (проект с кодовым названием Whidbey), \csharp{} 2.0 окончательно вышел 7 ноября 2005 года вместе с Visual Studio 2005 и \dotnet{} 2.0. 
Ниже перечислены новые возможности в версии 2.0
\begin{itemize}
  \item Частичные типы (разделение реализации класса более чем на один файл).

  \item Обобщённые, или параметризованные типы (generics). 
  В отличие от шаблонов \cpp{}, они поддерживают некоторые дополнительные возможности и работают на уровне виртуальной машины.
  Вместе с тем, параметрами обобщённого типа не могут быть выражения, они не могут быть полностью или частично специализированы, не поддерживают шаблонных параметров по умолчанию, от шаблонного параметра нельзя наследоваться.

  \item Новая форма итератора, позволяющая создавать сопрограммы с помощью ключевого слова \lstinline[style=csharpinlinestyle]!yield!, подобно Python и Ruby.
  
  \item Анонимные методы, обеспечивающие функциональность замыканий.

  \item Оператор ??: \lstinline!return obj1 ?? obj2;! означает (в нотации \csharp{} 1.0) \lstinline[style=csharpinlinestyle]/return obj1!=null ? obj1 : obj2;/.

  \item Обнуляемые (nullable) типы"=значения (обозначаемые вопросительным знаком, например, \lstinline[style=csharpinlinestyle]!int? i = null;!), представляющие собой те же самые типы-значения, способные принимать также значение null. 
  Такие типы позволяют улучшить взаимодействие с базами данных через язык SQL.

  \item Поддержка 64-разрядных вычислений позволяет увеличить адресное пространство и использовать 64-разрядные примитивные типы данных~\cite{csharp_wiki_2013_ru}.
\end{itemize}

Третья версия языка имела одно большое нововведение "--- Language Integrated Query (LINQ), для реализации которого в языке дополнительно появилось множество дополнительных возможностей. 
Ниже приведены некоторые из них:
\begin{itemize}
  \item Ключевые слова \lstinline[style=csharpinlinestyle]!select!, \lstinline[style=csharpinlinestyle]!from!, \lstinline[style=csharpinlinestyle]!where!, позволяющие делать запросы из SQL, XML, коллекций и т.\,п.

  \item Инициализацию объекта вместе с его свойствами:
  \begin{lstlisting}[style=csharpinlinestyle]
Customer c = new Customer(); c.Name = "James"; c.Age=30;
  \end{lstlisting}
  можно записать как
  \begin{lstlisting}[style=csharpinlinestyle]
Customer c = new Customer { Name = "James", Age = 30 };
  \end{lstlisting}

  \item Лямбда-выражения:
  \begin{lstlisting}[style=csharpinlinestyle]
listOfFoo.Where(delegate(Foo x) { return x.size > 10; });
  \end{lstlisting}
  теперь можно записать как
  \begin{lstlisting}[style=csharpinlinestyle]
listOfFoo.Where(x => x.size > 10);
  \end{lstlisting}

  \item Деревья выражений "--- лямбда-выражения теперь могут быть представлены в виде структуры данных, доступной для обхода во время выполнения, тем самым позволяя транслировать строго типизированные \csharp{}-выражения в другие домены (например, выражения SQL).

  \item Вывод типов локальной переменной: \lstinline[style=csharpinlinestyle]!var x = "hello";! вместо \lstinline[style=csharpinlinestyle]!string x = "hello";!

  \item Безымянные типы: \lstinline[style=csharpinlinestyle]!var x = new { Name = "James" };!

  \item Методы-расширения "--- добавление метода в существующий класс с помощью ключевого слова \lstinline[style=csharpinlinestyle]!this! при первом параметре статической функции.

  \item Автоматические свойства: компилятор сгенерирует закрытое  поле и соответствующие аксессор и мутатор для кода вида
  \begin{lstlisting}[style=csharpinlinestyle]
public string Name { get; private set; }
  \end{lstlisting}

\end{itemize}
\csharp{} 3.0 совместим с \csharp{} 2.0 по генерируемому MSIL-коду; улучшения в языке "--- чисто синтаксические и реализуются на этапе компиляции~\cite{csharp_wiki_2013_ru}.

\vbnet{} 10.0 и \csharp{} 4.0 были выпущены в апреле 2010 года, одновременно с выпуском Visual Studio 2010.
Новые возможности в версии 4.0:
\begin{itemize}
  \item Возможность использования позднего связывания.
  \item Именованные и опциональные параметры.
  \item Новые возможности COM interop.
  \item Ковариантность и контрвариантность интерфейсов и делегатов.
  \item Контракты в коде (Code Contracts)~\cite{csharp_wiki_2013_ru}.
\end{itemize}

В \csharp{} 5.0 было немного нововведений, но они носят большую практическую ценность.
В новой версии появилась упрощенная поддержка выполнения асинхронных функций с помощью двух новых слов "---  \lstinline[style=csharpinlinestyle]!async! и \lstinline[style=csharpinlinestyle]!await!.
Ключевым словом \lstinline[style=csharpinlinestyle]!async! помечаются методы и лямбда"=выражения, которые внутри содержат ожидание выполнения асинхронных операций с помощью оператора \lstinline[style=csharpinlinestyle]!await!, который отвечает за преобразования кода метода во время компиляции.
